package tiny;

import java_cup.runtime.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal PROGRAM, TYPES, STRUCT, POINTER, VARIABLES, SUBPROGRAMS, SUBPROGRAM, IF, ENDIF, DO, ENDDO, 
         MAS, MENOS, POR, DIV, MOD, AND, OR, NOT, TOINT, TODOUBLE, ASIG, IGUAL, MENOR, MAYOR, MENOROIGUAL, MAYOROIGUAL,
         DISTINTO, PYCOMA, COMA, PAP, PCIERRE, LLAVEAP, LLAVECIERRE, DOSPUNTOS, INT, BOOLEAN, DOUBLE, CAP, CCIERRE,
         PUNTO, FLECHA, AMP, TRUE, FALSE, ARRAY, READ, WRITE, NEW, DELETE;
terminal String NUMERO_NATURAL, NUMERO_REAL, ID;

// TODO: poner tipos a los no terminales
non terminal Programa, SeccionTipos, SeccionVariables, SeccionSubprogramas, DecTipos, DecVariables, DecSubprogramas, DecTipo,
             Tipo, Campos, Campo, DecVariable, DecSubprograma, Parametros, ListaParametros, Parametro, Instruccion,
             IAsig, ICond, IBucle, IBloque, ILlamada, IRead, IWrite, INew, IDelete, Designador, Exp0, Exp1, Exp2, Exp3, 
             Exp4, Instrucciones, Casos, Caso, Argumentos, ListaArgumentos, OpComp, OpAditivo, OpMultiplicativo, 
             OpUnario;

Programa ::= PROGRAM SeccionTipos: aDeST SeccionVariables: aDeSV SeccionSubprogramas: aDeSS IBloque: aDeIB
	{: RESULT = ops.decprograma(aDeST, aDeSV, aDeSS, aDeIB); :};
SeccionTipos ::= TYPES DecTipos: aDeDT
	{: RESULT = ops.decsectipos(aDeDT); :};
SeccionTipos ::=  
	{: RESULT = ops.decsectiposvacia(); :};
SeccionVariables ::= VARIABLES DecVariables: aDeDV
	{: RESULT = ops.decsecvar(aDeDV); :};
SeccionVariables ::=  
	{: RESULT = ops.decsecvarvacia(); :};
SeccionSubprogramas ::= SUBPROGRAMS DecSubprogramas: aDeDSP
	{: RESULT = ops.decsecsubprogramas(aDeDSP); :};
SeccionSubprogramas ::=  
	{: RESULT = ops.decsecsubprogramasvacia(); :};
	
DecTipos ::= DecTipos: aDeDTS1 PYCOMA DecTipo: aDeDT
	{: RESULT = ops.dectiposcomp(aDeDTS1, aDeDT); :};
DecTipos ::= DecTipo: aDeDT
	{: RESULT = ops.dectipossimp(aDeDT); :};
DecTipo ::= ID: lexDeID DOSPUNTOS Tipo: aDeTipo
	{: RESULT = ops.dectiposstring(lexDeID, aDeTipo); :};
Tipo    ::= INT
	{: RESULT = ops.tipoint(); :};
Tipo    ::= DOUBLE
	{: RESULT = ops.tipodouble(); :};
Tipo    ::= BOOLEAN
	{: RESULT = ops.tipoboolean(); :};
Tipo    ::= ID: lexDeID
	{: RESULT = ops.tipoid(lexDeID); :};
Tipo    ::= ARRAY Tipo: aDeTipo CAP NUMERO_NATURAL: lexDeNN CCIERRE
	{: RESULT = ops.tipoint(aDeTipo, lexDeNN); :};
Tipo    ::= STRUCT LLAVEAP Campos: aDeCampos LLAVECIERRE
	{: RESULT = ops.tipostruct(aDeCampos); :};
Tipo    ::= POINTER Tipo: aDeTipo;
	{: RESULT = ops.tipopointer(aDeTipo); :};
Campos  ::= Campos: aDeCampos1 PYCOMA Campo: aDeCampo
	{: RESULT = ops.dectiposcomp(aDeCampos1, aDeCampo); :};
Campos  ::= Campo: aDeCampo
	{: RESULT = ops.dectipossimp(aDeCampo); :};
Campo   ::= ID: lexDeID DOSPUNTOS Tipo: aDeTipo
	{: RESULT = ops.dectipostring(lexDeID, aDeTipo); :};
	
DecVariables ::= DecVariables: aDeDVS1 PYCOMA DecVariable: aDeDV
	{: RESULT = ops.dectiposcomp(aDeDVS1, aDeDV); :};
DecVariables ::= DecVariable: aDeDV
	{: RESULT = ops.dectipossimp(aDeDV); :};
DecVariable ::= ID: lexDeID DOSPUNTOS Tipo: aDeTipo
	{: RESULT = ops.dectipostring(lexDeID, aDeTipo); :};

DecSubprogramas ::= DecSubprogramas: aDeDSPS1 PYCOMA DecSubprograma: aDeDSP
	{: RESULT = ops.decsubprogramacomp(aDeDSPS1, aDeDSP); :};
DecSubprogramas ::= DecSubprograma: aDeDSP
	{: RESULT = ops.decsubprogramasimp(aDeDSP); :};
DecSubprograma ::= SUBPROGRAM ID: lexDeID Parametros: aDeP SeccionTipos: aDeSTS SeccionVariables: aDeSVS SeccionSubprogramas: aDeSPS IBloque: aDeIB
	{: RESULT = ops.decsubprogram(lexDeID, aDeP, aDeSTS, aDeSVS, aDeSPS, aDeIB); :};
Parametros ::= PAP ListaParametros: aDeLPS PCIERRE
	{: RESULT = aDeLPS; :};
Parametros ::= PAP PCIERRE
	{: RESULT = ops.parametrosvacia(); :};
ListaParametros ::= ListaParametros: aDeLPS COMA Parametro: aDeP
	{: RESULT = ops.parametroscomp(aDeLSP, aDeP); :};
ListaParametros ::= Parametro: aDeP
	{: RESULT = ops.parametrossimp(aDeP); :};
Parametro ::= ID: lexDeID DOSPUNTOS Tipo: aDeTipo
	{: RESULT = ops.paramvalor(lexDeID, aDeTipo); :};
Parametro ::= MP ID: lexDeID DOSPUNTOS Tipo: aDeTipo
	{: RESULT = ops.paramrefer(lexDeID, aDeTipo); :};

Instruccion ::= IAsig: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= IBloque: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= ICond: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= IBucle: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= ILlamada: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= IRead: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= IWrite: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= INew: aDeIInstr
	{: RESULT = aDeIInstr; :};
Instruccion ::= IDelete: aDeIInstr
	{: RESULT = aDeIInstr; :};
                
IAsig ::= Designador: aDeD ASIG Exp0: aDeExp0
	{: RESULT = ops.instasignacion(aDeD, aDeExp0); :};

IBloque ::= LLAVEAP Instrucciones: aDeIS LLAVECIERRE
	{: RESULT = aDeIS; :};
IBloque ::= LLAVEAP LLAVECIERRE
	{: RESULT = ops.decinstvacia(); :};
Instrucciones ::= Instrucciones: aDeIS PYCOMA Instruccion: aDeI
	{: RESULT = ops.decinstcomp(aDeIS, aDeI); :};
Instrucciones ::= Instruccion: aDeI
	{: RESULT = ops.decinstsimp(aDeI); :};
	
// TODO: a partir de aqu√≠...
	
ICond ::= IF Casos ENDIF ;
Casos ::= Casos CAP CCIERRE Caso | Caso; 
Caso  ::= Exp0 DOSPUNTOS IBloque;
IBucle ::= DO Casos ENDDO;
ILlamada  ::= ID Argumentos;
IRead ::= READ Designador;
IWrite ::= WRITE Exp0;
INew ::= NEW Designador;
IDelete ::= DELETE Designador;
Argumentos ::= PAP ListaArgumentos PCIERRE | PAP PCIERRE;
ListaArgumentos ::= ListaArgumentos COMA Exp0 | Exp0;
Designador  ::= ID | Designador CAP Exp0 CCIERRE | Designador PUNTO ID | Designador FLECHA;
Exp0 ::= Exp1 OpComp Exp1 | Exp1;
Exp1 ::= Exp1 OpAditivo Exp2 | Exp2;
Exp2 ::= Exp2 OpMultiplicativo Exp3 | Exp3;
Exp3 ::= OpUnario Exp3 | Exp4;
Exp4 ::= TRUE | FALSE | NUMERO_NATURAL | NUMERO_REAL | Designador | PAP Exp0 PCIERRE;
OpComp ::= IGUAL | DISTINTO  | MAYOR | MAYOROIGUAL | MENOR  | MENOROIGUAL;
OpAditivo ::= MAS | MENOS | OR;
OpMultiplicativo ::= POR | DIV | MOD | AND;
OpUnario ::= MENOS | NOT | TOINT | TODOUBLE;
